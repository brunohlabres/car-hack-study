# -*- coding: utf-8 -*-
"""knn.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CxQSk1-JFOudyVq7sklVLVslwslmmU9k
"""

from google.colab import drive
drive.mount('/content/drive')

import numpy as np 
import pandas as pd
import sys
import os
from sklearn.neighbors import KNeighborsClassifier
import matplotlib.pyplot as plt
from sklearn.model_selection import cross_val_score
from sklearn.model_selection import cross_val_predict
from sklearn.tree import DecisionTreeClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import auc
from sklearn.metrics import ConfusionMatrixDisplay
from sklearn.metrics import RocCurveDisplay
from sklearn.model_selection import StratifiedKFold
from sklearn.ensemble import RandomForestClassifier
from sklearn.neural_network import MLPClassifier
from sklearn.preprocessing import Binarizer
from sklearn.metrics import PrecisionRecallDisplay
import struct
from sklearn.model_selection import GridSearchCV

print("Reading data...")
normal = 0
attack = 1
np.set_printoptions(threshold=sys.maxsize)
NUM_EXEMPLOS = 10000

column_names = ['timestamp', 'can_id', 'dlc', 'data0', 'data1','data2','data3','data4','data5','data6','data7','type']
df_fuzzy = pd.read_csv('/content/drive/MyDrive/data/Fuzzy_dataset.csv' , names = column_names)
df_dos = pd.read_csv('/content/drive/MyDrive/data/DoS_dataset.csv', names = column_names)
df_rpm = pd.read_csv('/content/drive/MyDrive/data/RPM_dataset.csv', names = column_names)
df_gear = pd.read_csv('/content/drive/MyDrive/data/gear_dataset.csv', names = column_names)
df_normal = pd.read_fwf('/content/drive/MyDrive/data/normal_run_data.txt', names = column_names)

df1 = df_fuzzy.loc[df_fuzzy['type'] == 'T'].drop_duplicates(subset=['data0', 'data1', 'data3', 'data4', 'data5', 'data6', 'data7']).head(NUM_EXEMPLOS)
df1["type"] = attack

df2 = df_fuzzy.loc[df_fuzzy['type'] == 'R'].drop_duplicates(subset=['data0', 'data1', 'data3', 'data4', 'data5', 'data6', 'data7']).head(NUM_EXEMPLOS) #df_normal.drop_duplicates(subset=['data0', 'data1', 'data3', 'data4', 'data5', 'data6', 'data7']).head(NUM_EXEMPLOS)
df2["type"] = normal

df3 = df_dos.loc[df_dos['type'] == 'T'].drop_duplicates(subset=['data0', 'data1', 'data3', 'data4', 'data5', 'data6', 'data7']).head(NUM_EXEMPLOS)
df3["type"] = attack

df4 = df_rpm.loc[df_rpm['type'] == 'T'].drop_duplicates(subset=['data0', 'data1', 'data3', 'data4', 'data5', 'data6', 'data7']).head(NUM_EXEMPLOS)
df4["type"] = attack

df5 = df_gear.loc[df_gear['type'] == 'T'].drop_duplicates(subset=['data0', 'data1', 'data3', 'data4', 'data5', 'data6', 'data7']).head(NUM_EXEMPLOS)
df5["type"] = attack

df_attacks = pd.concat([df1, df3, df4, df5], ignore_index=True)
df_attacks = df_attacks.sample(n=len(df_attacks), random_state=42)
df_attacks = df_attacks.head(NUM_EXEMPLOS)

df = pd.concat([df2, df_attacks], ignore_index=True)
df = df.sample(n=len(df), random_state=42)

print(df2.drop_duplicates(subset=['data0', 'data1', 'data3', 'data4', 'data5', 'data6', 'data7']).head(10).to_string())
print(df_attacks.drop_duplicates(subset=['data0', 'data1', 'data3', 'data4', 'data5', 'data6', 'data7']).head(10).to_string())


print("Extracting features...")

# transform hexa to decimal int(str(x),16)
b16 = lambda x: float.fromhex(str(x))  #int(bin(int(hex(x), 16)), 2)

df['data0'] = df['data0'].apply(b16)
df['data1'] = df['data1'].apply(b16)
df['data2'] = df['data2'].apply(b16)
df['data3'] = df['data3'].apply(b16)
df['data4'] = df['data4'].apply(b16)
df['data5'] = df['data5'].apply(b16)
df['data6'] = df['data6'].apply(b16)
df['data7'] = df['data7'].apply(b16)


#features
X1 = df[df.columns[3:11]].to_numpy().astype(int)
#classes
Y1 = df["type"].to_numpy()

cv = StratifiedKFold(n_splits=5,shuffle=False,random_state=None)
###################### CLASSIFICADOR ENTRE OS 4 ATAQUES ##################################
print("##################################")
########################## KNN   ###############################################
print("------------------------ KNN ------------------------")
tprs = []
aucs = []
mean_fpr = np.linspace(0, 1, 100)
fig, ax = plt.subplots()
knn = KNeighborsClassifier()
cv = StratifiedKFold(n_splits=5,shuffle=False,random_state=None)
# Paramentros para a Grid Search
param_grid_knn = {
    "n_neighbors": [2,3,5,7,9],
    "weights": ['uniform','distance'],
    "algorithm": ['ball_tree', 'kd_tree', 'brute']
}

# Encontra os melhores parametros
for i, (train, test) in enumerate(cv.split(X1, Y1)):
    knn.fit(X1[train], Y1[train])
    grid_cv = GridSearchCV(knn, param_grid_knn, scoring="roc_auc", n_jobs=-1, cv=3).fit(X1, Y1)
    print("Param for GS", grid_cv.best_params_)
    print("CV score for GS", grid_cv.best_score_)
    break

# Cria o classificador com os melhores parametro
knn = KNeighborsClassifier(**grid_cv.best_params_)
for i, (train, test) in enumerate(cv.split(X1, Y1)):
    knn.fit(X1[train], Y1[train])
    display = PrecisionRecallDisplay.from_estimator(
    knn, X1[test], Y1[test], name="Precision Recall KNN"
    )
    _ = display.ax_.set_title("2-class Precision-Recall curve KNN")
    ConfusionMatrixDisplay.from_estimator(knn,X1[test], Y1[test])
    viz = RocCurveDisplay.from_estimator(
        knn,
        X1[test],
        Y1[test],
        name="ROC fold {}".format(i),
        alpha=0.3,
        lw=1,
        ax=ax,
    )
    interp_tpr = np.interp(mean_fpr, viz.fpr, viz.tpr)
    interp_tpr[0] = 0.0
    tprs.append(interp_tpr)
    aucs.append(viz.roc_auc)

ax.plot([0, 1], [0, 1], linestyle="--", lw=2, color="r", label="Chance", alpha=0.8)

mean_tpr = np.mean(tprs, axis=0)
mean_tpr[-1] = 1.0
mean_auc = auc(mean_fpr, mean_tpr)
std_auc = np.std(aucs)
ax.plot(
    mean_fpr,
    mean_tpr,
    color="b",
    label=r"Mean ROC (AUC = %0.2f $\pm$ %0.2f)" % (mean_auc, std_auc),
    lw=2,
    alpha=0.8,
)

std_tpr = np.std(tprs, axis=0)
tprs_upper = np.minimum(mean_tpr + std_tpr, 1)
tprs_lower = np.maximum(mean_tpr - std_tpr, 0)
ax.fill_between(
    mean_fpr,
    tprs_lower,
    tprs_upper,
    color="grey",
    alpha=0.2,
    label=r"$\pm$ 1 std. dev.",
)

ax.set(
    xlim=[-0.05, 1.05],
    ylim=[-0.05, 1.05],
    title="Curva ROC",
)
ax.legend(loc="lower right")
plt.show()